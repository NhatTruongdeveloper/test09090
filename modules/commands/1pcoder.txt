// =======================================================================================
// ============================ T∆Ø·ªúNG AI v8.4.0 - HO√ÄN CH·ªàNH ============================
// =======================================================================================

const TUONGS = ["tuong", "t∆∞·ªùng"];
const YOUTUBE_API_KEY = "AIzaSyD16U7WwrIFGOKijx0GR_3hU6p7Ww7JObM"; // L∆∞u √Ω b·∫£o m·∫≠t
const GEMINI_API_KEY = "AIzaSyBRS5q0W9czyKuquLZ9-Ls-zZTVPaqR0qg"; // L∆∞u √Ω b·∫£o m·∫≠t
const GEMINI_MODEL = "gemini-1.5-flash-latest";
const GIPHY_KEY = "x2DSDHSAKfI06mgb0ON56fxtp9JAUTuQ";
const THECATAPI_KEY = "live_R3gMhw4dZ9qymWsBCSjbfzmelZpiawsrH4VwR8qmEs316MDgvwcvSMDgWuxkEdK3";
const GENIUS_API_KEY = "YOUR_GENIUS_API_KEY"; // <<< THAY API KEY C·ª¶A B·∫†N V√ÄO ƒê√ÇY
const OPENWEATHERMAP_API_KEY = "619bf420046f8164a5246c084d56e547"; // API Key b·∫°n cung c·∫•p

const fs = require("fs-extra");
const path = require("path");
const axios = require("axios");
const ytdl = require("@distube/ytdl-core");
const ffmpeg = require("fluent-ffmpeg");
const qs = require("qs");
const { v4: uuidv4 } = require('uuid');

const DATA_DIR = path.join(__dirname, "../../pdata/AIdata");
const TUONG_DIR = path.join(DATA_DIR, "tuong_ai");
const VISION_CACHE_DIR = path.join(TUONG_DIR, "cache_vision");
const TMP_DIR = path.join(__dirname, "tmp_tuong");

[DATA_DIR, TUONG_DIR, VISION_CACHE_DIR, TMP_DIR].forEach(dir => fs.ensureDirSync(dir));

const userDataFile = path.join(TUONG_DIR, "user_data.json");
const groupDataFile = path.join(TUONG_DIR, "group_data.json");
const memoriesFile = path.join(TUONG_DIR, "memories.json");
const playlistsFile = path.join(TUONG_DIR, "playlists.json");
const remindersFile = path.join(TUONG_DIR, "reminders.json");
const autoAIFile = path.join(TUONG_DIR, "auto_ai.json");

const allDataFiles = [userDataFile, groupDataFile, memoriesFile, playlistsFile, remindersFile, autoAIFile];
allDataFiles.forEach(file => {
  if (!fs.existsSync(file)) fs.writeFileSync(file, JSON.stringify({}));
});

let userData = {}; try { userData = JSON.parse(fs.readFileSync(userDataFile, 'utf-8')); } catch (e) { console.log("Kh√¥ng th·ªÉ t·∫£i userData.json, d√πng object r·ªóng."); }
let groupData = {}; try { groupData = JSON.parse(fs.readFileSync(groupDataFile, 'utf-8')); } catch (e) { console.log("Kh√¥ng th·ªÉ t·∫£i groupData.json, d√πng object r·ªóng."); }
let autoAI = {}; try { autoAI = JSON.parse(fs.readFileSync(autoAIFile, 'utf-8')); } catch (e) { console.log("Kh√¥ng th·ªÉ t·∫£i autoAI.json, d√πng object r·ªóng."); }

const CONVERSATION_TIMEOUT_MS = 5 * 60 * 1000;
let activeConversations = {};
let BOT_ID = null;

// --- C√ÅC H√ÄM HELPER ---
function saveData(type) {
  try {
    if (type === 'userData') fs.writeFileSync(userDataFile, JSON.stringify(userData, null, 2));
    else if (type === 'groupData') fs.writeFileSync(groupDataFile, JSON.stringify(groupData, null, 2));
    else if (type === 'autoAI') fs.writeFileSync(autoAIFile, JSON.stringify(autoAI, null, 2));
  } catch (e) { console.error(`L·ªói l∆∞u ${type}:`, e); }
}

function unsign(str) { 
  return (str || "").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9 ]+/g, " ").replace(/\s+/g, " ").trim();
}

function parseMediaRequest(userMessage, type = "detect") {
    const msg = unsign(userMessage);
    const negPhrases = ["kh√¥ng", "ƒë·ª´ng", "lo·∫°i tr·ª´", "tr√°nh", "not", "no"];
    let negKeywords = [];
    let positive = msg;
    negPhrases.forEach(neg => {
        if (msg.includes(neg)) {
            let after = msg.split(neg).pop().replace(/^(g·ª≠i|video|nh·∫°c|clip|gif|meme)/, "").trim();
            if (after && after.length > 1) negKeywords.push(after);
            positive = positive.replace(neg + " " + after, "");
        }
    });

    if (/(bu·ªìn|ch√°n|sad|üò≠|üò¢|stress)/.test(userMessage)) return { type: "mp3", query: "nh·∫°c bu·ªìn", mood: "sad", negKeywords };
    if (/(vui|meme|h√†i|c∆∞·ªùi|happy|üòÜ)/.test(userMessage)) return { type: "mp4", query: "clip h√†i", mood: "happy", negKeywords };
    if (/(gif|·∫£nh ƒë·ªông)/.test(userMessage)) return { type: "gif", query: positive.replace(/(gif|·∫£nh ƒë·ªông)/g, "").trim(), negKeywords };

    let req = null;
    if (type === "detect" || type === "video") {
        const videoWords = ["video", "clip", "youtube", "phim", "trailer", "mv", "show"];
        videoWords.forEach(w => { if (positive.includes(w)) req = { type: "mp4", query: positive.split(w).pop().trim() }; });
    }
    if ((type === "detect" || type === "mp3") && !req) {
        const mp3Words = ["nhac", "mp3", "audio", "bai hat", "song", "music"];
        mp3Words.forEach(w => { if (positive.includes(w)) req = { type: "mp3", query: positive.split(w).pop().trim() }; });
    }
    if ((type === "detect" || type === "image") && !req) {
        const imgWords = ["·∫£nh", "anh", "h√¨nh", "meme", "wallpaper"];
        imgWords.forEach(w => { if (positive.includes(w)) req = { type: "img", query: positive.split(w).pop().trim() }; });
    }
    if (req) req.negKeywords = negKeywords;
    return req;
}

async function searchYouTube(query, maxResults = 5, negKeywords = []) {
    try {
        const response = await axios.get(`https://www.googleapis.com/youtube/v3/search`, {
            params: { q: query, key: YOUTUBE_API_KEY, part: "snippet", maxResults, type: "video", order: "relevance", safeSearch: "moderate" }
        });
        let results = response.data.items.map((video) => ({
            title: video.snippet.title,
            videoId: video.id.videoId,
            thumbnail: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default.url,
            url: `https://www.youtube.com/watch?v=${video.id.videoId}`,
            channel: video.snippet.channelTitle,
            publishedAt: video.snippet.publishedAt
        }));
        const keywords = query.toLowerCase().split(" ").filter(k => k.length > 1);
        results = results.filter(r => keywords.every(w => unsign(r.title).includes(unsign(w))));
        if (negKeywords && negKeywords.length) {
            results = results.filter(r => !negKeywords.some(neg => unsign(r.title).includes(unsign(neg))));
        }
        return results;
    } catch (e) { console.error("L·ªói searchYouTube:", e.message); return []; }
}

async function downloadYouTubeMp3(videoId, outPath, maxSeconds = 300) {
  return new Promise(async (resolve, reject) => {
    try {
      const stream = ytdl(videoId, { quality: "highestaudio", filter: "audioonly", highWaterMark: 1 << 25 });
      ffmpeg(stream).audioBitrate(128).audioCodec('libmp3lame').setDuration(maxSeconds).format("mp3")
        .on("end", () => resolve(outPath)).on("error", e => reject(e)).save(outPath);
    } catch (e) { reject(e); }
  });
}

async function downloadYouTubeMp4(videoId, outPath, maxSeconds = 300, quality = "360p") {
  return new Promise(async (resolve, reject) => {
    try {
      const info = await ytdl.getInfo(videoId);
      let format = info.formats.find(f => f.qualityLabel === quality && f.container === "mp4" && f.hasAudio && f.hasVideo) || 
                   info.formats.find(f => f.itag === 18) || 
                   info.formats.find(f => f.itag === 22);   
      if (!format) format = ytdl.chooseFormat(info.formats, { quality:"lowestvideo", filter:"videoandaudio", container: "mp4"});
      if (!format) return reject("Kh√¥ng t√¨m th·∫•y video MP4 ph√π h·ª£p!");
      const stream = ytdl(videoId, { format, highWaterMark: 1 << 25 });
      ffmpeg(stream).setDuration(maxSeconds).videoCodec('libx264').audioCodec('aac').format("mp4")
        .on("end", () => resolve(outPath)).on("error", e => reject(e)).save(outPath);
    } catch (e) { reject(e); }
  });
}

async function searchGif(query) {
  try {
    const q = encodeURIComponent(query);
    const res = await axios.get(`https://api.giphy.com/v1/gifs/search?${qs.stringify({ q, api_key: GIPHY_KEY, limit: 5 })}`);
    if (res.data.data && res.data.data.length > 0) {
        const randomIndex = Math.floor(Math.random() * res.data.data.length);
        return res.data.data[randomIndex]?.images?.original?.url || null;
    }
    return null;
  } catch { return null; }
}

async function searchLyrics(song) {
  try {
    if (!GENIUS_API_KEY || GENIUS_API_KEY === "YOUR_GENIUS_API_KEY") {
        return `T∆∞·ªùng ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t API t√¨m l·ªùi b√†i h√°t (Genius). L·ªùi b√†i h√°t cho "${song}" s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau nha!`;
    }
    return `T√≠nh nƒÉng t√¨m l·ªùi b√†i h√°t cho "${song}" ƒëang ƒë∆∞·ª£c T∆∞·ªùng ph√°t tri·ªÉn th√™m. Hi·ªán t·∫°i T∆∞·ªùng ch∆∞a t√¨m ƒë∆∞·ª£c ƒë√¢u :P`;
  } catch (e) { console.error("L·ªói searchLyrics:", e); return `T∆∞·ªùng t√¨m l·ªùi b√†i h√°t "${song}" kh√¥ng th·∫•y r·ªìi :(`; }
}

async function createQrCode(text) {
  return `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(text)}`;
}

async function catImage() {
  try {
    const res = await axios.get("https://api.thecatapi.com/v1/images/search", { headers: { 'x-api-key': THECATAPI_KEY } });
    return res.data[0]?.url;
  } catch { return null; }
}

function getImageMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  if ([".jpg", ".jpeg"].includes(ext)) return "image/jpeg";
  if (ext === ".png") return "image/png";
  if (ext === ".webp") return "image/webp";
  return "application/octet-stream";
}

function imageToBase64(filePath) {
  return fs.readFileSync(filePath, { encoding: "base64" });
}

function getMoodBasedPrompt(basePrompt, threadID, forVision = false) {
    const groupMood = groupData[threadID]?.personality || "m·∫∑c ƒë·ªãnh";
    let finalPrompt = basePrompt;
    let moodPrefix = "";
    if (groupMood === "h√†i h∆∞·ªõc") {
        moodPrefix = `B·∫°n l√† T∆∞·ªùng AI, m·ªôt c√¢y h√†i ch√≠nh hi·ªáu c·ªßa nh√≥m, h√£y tr·∫£ l·ªùi c·ª±c k·ª≥ d√≠ d·ªèm, troll v√† h√†i h∆∞·ªõc. ${forVision ? 'Khi ph√¢n t√≠ch ·∫£nh, h√£y th√™m nhi·ªÅu mu·ªëi v√† b√¨nh lu·∫≠n th·∫≠t b√° ƒë·∫°o!' : ''} `;
    } else if (groupMood === "nghi√™m t√∫c") {
        moodPrefix = `B·∫°n l√† T∆∞·ªùng AI, m·ªôt tr·ª£ l√Ω chuy√™n nghi·ªáp, th√¥ng th√°i v√† l·ªãch s·ª±. H√£y tr·∫£ l·ªùi m·ªôt c√°ch ch√≠nh x√°c v√† r√µ r√†ng. ${forVision ? 'Ph√¢n t√≠ch ·∫£nh m·ªôt c√°ch kh√°ch quan v√† chi ti·∫øt.' : ''} `;
    } else if (groupMood === "d·ªÖ th∆∞∆°ng") {
        moodPrefix = `B·∫°n l√† T∆∞·ªùng AI, si√™u c·∫•p ƒë√°ng y√™u, moe moe l·∫Øm nhaaa <3. H√£y tr·∫£ l·ªùi th·∫≠t cute v√† t√¨nh c·∫£m. ${forVision ? 'Xem ·∫£nh xong b√¨nh lu·∫≠n cute x·ªâu nha.' : ''} `;
    }
    if (moodPrefix) {
        const knownSalutations = [
            "B·∫°n l√† T∆∞·ªùng AI, m·ªôt tr·ª£ l√Ω ·∫£o ƒë√°ng y√™u v√† th√¥ng minh.",
            "B·∫°n l√† T∆∞·ªùng AI, m·ªôt tr·ª£ l√Ω ·∫£o th√¥ng minh v√† th√¢n thi·ªán.",
            "B·∫°n l√† T∆∞·ªùng AI, tr·ª£ l√Ω ·∫£o th√¥ng minh v√† th√¢n thi·ªán."
        ];
        let replaced = false;
        for (const salutation of knownSalutations) {
            if (basePrompt.startsWith(salutation)) {
                finalPrompt = moodPrefix + basePrompt.substring(salutation.length).trim();
                replaced = true;
                break;
            }
        }
        if (!replaced) finalPrompt = moodPrefix + basePrompt;
    }
    return finalPrompt;
}

async function geminiVisionRequest({ prompt, imagePath, threadID }) {
  const mimeType = getImageMimeType(imagePath);
  const imgBase64 = imageToBase64(imagePath);
  const moodAdjustedPrompt = getMoodBasedPrompt(prompt, threadID, true);
  const reqBody = { contents: [{ parts: [{ text: moodAdjustedPrompt }, { inline_data: { mime_type: mimeType, data: imgBase64 } }] }] };
  try {
    const { data } = await axios.post( `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, reqBody, { headers: { "Content-Type": "application/json" } });
    return data?.candidates?.[0]?.content?.parts?.[0]?.text || "[Gemini Vision] T∆∞·ªùng kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ ·∫£nh.";
  } catch (error) {
    console.error("L·ªói API Gemini Vision:", error.response?.data?.error?.message || error.message);
    return "[Gemini Vision] T∆∞·ªùng g·∫∑p l·ªói khi ph√¢n t√≠ch ·∫£nh: " + (error.response?.data?.error?.message || "L·ªói kh√¥ng x√°c ƒë·ªãnh");
  }
}

async function geminiTextRequest(prompt, threadID) {
  const moodAdjustedPrompt = getMoodBasedPrompt(prompt, threadID, false);
  const reqBody = { contents: [{ parts: [{ text: moodAdjustedPrompt }] }] };
  try {
    const { data } = await axios.post( `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, reqBody, { headers: { "Content-Type": "application/json" } });
    return data?.candidates?.[0]?.content?.parts?.[0]?.text || "[Gemini] T∆∞·ªùng kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ AI.";
  } catch (error) {
    console.error("L·ªói API Gemini Text:", error.response?.data?.error?.message || error.message);
    return "[Gemini] T∆∞·ªùng g·∫∑p l·ªói khi suy nghƒ©: " + (error.response?.data?.error?.message || "L·ªói kh√¥ng x√°c ƒë·ªãnh");
  }
}

async function getAIResponse(userMessage, userState, memory, context, threadID) {
  let basePrompt = `B·∫°n l√† T∆∞·ªùng AI, m·ªôt tr·ª£ l√Ω ·∫£o ƒë√°ng y√™u v√† th√¥ng minh. H√£y tr·∫£ l·ªùi ng∆∞·ªùi d√πng m·ªôt c√°ch NG·∫ÆN G·ªåN (t·∫ßm 20-50 t·ª´), th√¢n thi·ªán, kh√¥ng c·∫ßn nh·∫Øc l·∫°i c√¢u h·ªèi c·ªßa h·ªç, v√† th·ªÉ hi·ªán m·ªôt ch√∫t c√° t√≠nh d·ªÖ th∆∞∆°ng.`;
  basePrompt += "\n\nNg∆∞·ªùi d√πng nh·∫Øn: \"" + userMessage + "\"";
  try {
    return await geminiTextRequest(basePrompt, threadID);
  } catch (e) {
    console.error("L·ªói g·ªçi getAIResponse (geminiTextRequest):", e);
    return "Ui, T∆∞·ªùng ƒëang b·ªã \"ƒë·ª©ng h√¨nh\" m·ªôt ch√∫t x√≠u, b·∫°n th·ª≠ l·∫°i sau nha! ü§ñüíñ";
  }
}

async function sendGeneratedQrCode(api, threadID, messageID, qrDataToEncode, successMessage) {
    if (qrDataToEncode) {
        const qrImageUrl = await createQrCode(qrDataToEncode);
        try {
            const stream = await axios({ url: qrImageUrl, responseType: "stream" }).then(r => r.data);
            return api.sendMessage({ body: successMessage, attachment: stream }, threadID, messageID);
        } catch (e) {
            console.error("L·ªói g·ª≠i QR code:", e);
            return api.sendMessage("T∆∞·ªùng t·∫°o QR ƒë∆∞·ª£c r·ªìi m√† g·ª≠i l√™n b·ªã l·ªói m·∫•t ti√™u üò• B·∫°n th·ª≠ l·∫°i xem sao.", threadID, messageID);
        }
    }
}

async function downloadAndSendChosenMedia(api, threadID, messageID, senderID, chosenVideo, mediaType, quality = "360p") {
    const ext = mediaType === "mp3" ? "mp3" : "mp4";
    const filePath = path.join(TMP_DIR, `${chosenVideo.videoId}_${Date.now()}.${ext}`);
    try {
        api.sendMessage(`‚è≥ T∆∞·ªùng ƒëang t·∫£i ${mediaType === "mp3" ? "b√†i h√°t" : "video"} "${chosenVideo.title}" n√®... Ch·ªù T∆∞·ªùng x√≠u nha!`, threadID, null, messageID); // Reply v√†o tin ch·ªçn s·ªë
        if (mediaType === "mp3") await downloadYouTubeMp3(chosenVideo.videoId, filePath, 300);
        else await downloadYouTubeMp4(chosenVideo.videoId, filePath, 300, quality);

        let msgData = {
            body: `‚úÖ Xong r·ªìi n√®! ${mediaType === "mp3" ? "B√†i h√°t" : "Video"} "${chosenVideo.title}" c·ªßa b·∫°n ƒë√¢y.\nüîó Link g·ªëc: https://www.youtube.com/watch?v=$${chosenVideo.videoId}`,
            attachment: fs.createReadStream(filePath)
        };
        api.sendMessage(msgData, threadID, () => { if (fs.existsSync(filePath)) fs.unlinkSync(filePath); });

        if (mediaType === "mp3") {
            api.sendMessage({ body: `B·∫°n c√≥ mu·ªën T∆∞·ªùng t√¨m l·ªùi b√†i h√°t "${chosenVideo.title}" kh√¥ng? Reply "lyrics" n·∫øu mu·ªën nha!`, }, threadID, (err, info) => {
                if (err) return console.error("L·ªói g·ª≠i c√¢u h·ªèi lyrics:", err);
                if (global.client && global.client.handleReply && info) {
                    global.client.handleReply.push({
                        name: module.exports.config.name,
                        messageID: info.messageID,
                        author: senderID,
                        type: "lyrics_youtube",
                        songTitle: chosenVideo.title
                    });
                }
            });
        }
    } catch (e) {
        console.error(`L·ªói t·∫£i ${mediaType} "${chosenVideo.title}":`, e.message);
        if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
        api.sendMessage(`‚ùå Oops! T∆∞·ªùng t·∫£i ${mediaType === "mp3" ? "nh·∫°c" : "video"} "${chosenVideo.title}" b·ªã l·ªói r·ªìi. L·ªói: ${e.message}`, threadID);
    }
}

async function sendMedia(api, event, req, quality = "360p") {
    const { threadID, messageID, senderID } = event;
    if (req.type === "mp3" || req.type === "mp4") {
        let videoList = await searchYouTube(req.query, 5, req.negKeywords);
        if (!videoList || !videoList.length) {
            return api.sendMessage(`T∆∞·ªùng t√¨m h·ªïng th·∫•y ${req.type === "mp3" ? "nh·∫°c" : "video"} n√†o kh·ªõp v·ªõi "${req.query}" h·∫øt tr∆°n √°!`, threadID, messageID);
        }

        if (videoList.length === 1) {
            await downloadAndSendChosenMedia(api, threadID, messageID, senderID, videoList[0], req.type, quality);
        } else {
            let choiceMsg = `T∆∞·ªùng t√¨m th·∫•y m·∫•y ${req.type === "mp3" ? "b√†i h√°t" : "video"} n√†y n√®:\n\n`;
            const choices = [];
            videoList.forEach((video, index) => {
                choiceMsg += `${index + 1}. ${video.title}\n`;
                choices.push(video);
            });
            choiceMsg += `\nB·∫°n mu·ªën ch·ªçn s·ªë m·∫•y? Reply s·ªë t∆∞∆°ng ·ª©ng nha (v√≠ d·ª•: 1).\nHo·∫∑c reply "kh√°c" n·∫øu mu·ªën T∆∞·ªùng t√¨m l·∫°i v·ªõi t·ª´ kh√≥a kh√°c.`;

            api.sendMessage(choiceMsg, threadID, (err, info) => {
                if (err) return console.error("L·ªói g·ª≠i l·ª±a ch·ªçn YouTube:",err);
                if (global.client && global.client.handleReply && info) {
                    global.client.handleReply.push({
                        name: module.exports.config.name,
                        messageID: info.messageID,
                        author: senderID,
                        type: `yt_choice`, 
                        mediaType: req.type,
                        choices: choices,
                        originalQuery: req.query,
                        quality: quality
                    });
                }
            }, messageID);
        }
        return;
    }
    if (req.type === "gif") {
        const gifUrl = await searchGif(req.query);
        if (gifUrl) await api.sendMessage({ body: `GIF "${req.query}" cho b·∫°n n√® ü§∏`, attachment: await axios({ url: gifUrl, responseType: "stream" }).then(r => r.data) }, threadID, messageID);
        else await api.sendMessage("T∆∞·ªùng t√¨m h·ªïng ra GIF n√†o h·ª£p √Ω b·∫°n h·∫øt √°!", threadID, messageID);
        return;
    }
    if (req.type === "img") {
        if (/(m√®o|cat|meow)/i.test(req.query || "")) {
             const catImgUrl = await catImage();
            if (catImgUrl) return api.sendMessage({ body: " ·∫¢nh m√®o cute cho b·∫°n n√® üòª", attachment: await axios({ url: catImgUrl, responseType: "stream" }).then(r => r.data) }, threadID, messageID);
            else return api.sendMessage("Huhu, T∆∞·ªùng t√¨m ·∫£nh m√®o m√† kh√¥ng th·∫•y...", threadID, messageID);
        } else {
            return api.sendMessage(`T∆∞·ªùng ch∆∞a h·ªó tr·ª£ t√¨m ·∫£nh chung v·ªõi t·ª´ kh√≥a "${req.query}" ngo√†i ·∫£nh m√®o. B·∫°n th·ª≠ d√πng Google xem sao nha!`, threadID, messageID);
        }
    }
}

async function handleGu(api, event, args, userKey) {
  const guQuery = args.replace(new RegExp(`^(${TUONGS.join("|")})\\s+set\\s+gu\\s+nhac\\s+`, "i"), "").trim();
  if (guQuery) {
      userData[userKey].music = guQuery.split(/,|;/).map(s => s.trim()).filter(s => s);
      saveData('userData');
      return api.sendMessage(`T∆∞·ªùng ƒë√£ nh·ªõ gu nh·∫°c c·ªßa b·∫°n l√†: ${userData[userKey].music.join(", ")} r·ªìi ƒë√≥ nha! üòâ`, event.threadID, event.messageID);
  } else {
      const currentGu = userData[userKey]?.music?.join(", ") || "ch∆∞a c√≥ g√¨ h·∫øt tr∆°n";
      return api.sendMessage(`Gu nh·∫°c c·ªßa b·∫°n hi·ªán t·∫°i l√†: ${currentGu}. D√πng "tuong set gu nhac [th·ªÉ lo·∫°i1], [th·ªÉ lo·∫°i2]" ƒë·ªÉ T∆∞·ªùng bi·∫øt nha.`, event.threadID, event.messageID);
  }
}

function parseTime(timeStr) {
    const now = new Date();
    timeStr = timeStr.toLowerCase();
    let match = timeStr.match(/sau\s+(\d+)\s+(ph√∫t|phut|p|gi·ªù|gio|g|h|ng√†y|ngay|n|d)/i);
    if (match) {
        const value = parseInt(match[1]);
        const unit = match[2];
        let newTime = new Date(now.getTime());
        if (unit.startsWith('p')) newTime.setMinutes(newTime.getMinutes() + value);
        else if (unit.startsWith('g') || unit.startsWith('h')) newTime.setHours(newTime.getHours() + value);
        else if (unit.startsWith('n') || unit.startsWith('d')) newTime.setDate(newTime.getDate() + value);
        return newTime.getTime();
    }
    match = timeStr.match(/(\d{1,2}):(\d{1,2})(?:\s+(\d{1,2})\/(\d{1,2})(?:\/(\d{4}|\d{2}))?)?/i);
    if (match) {
        const hour = parseInt(match[1]);
        const minute = parseInt(match[2]);
        let day = now.getDate();
        let month = now.getMonth();
        let year = now.getFullYear();
        if (match[3] && match[4]) {
            day = parseInt(match[3]);
            month = parseInt(match[4]) - 1;
            if (match[5]) { year = parseInt(match[5]); if (year < 100) year += 2000; }
        }
        const reminderDate = new Date(year, month, day, hour, minute, 0, 0);
        if (reminderDate.getTime() < now.getTime() && !(match[3] && match[4])) {
            reminderDate.setDate(reminderDate.getDate() + 1);
        }
        return reminderDate.getTime();
    }
    match = timeStr.match(/(?:(\d+)\s*(?:gi·ªù|g|h))?\s*(?:(\d+)\s*(?:ph√∫t|p))?\s*(n·ªØa|nuÃõÃÉa)/i);
    if (match && (match[1] || match[2])) {
        const hoursToAdd = parseInt(match[1] || 0);
        const minutesToAdd = parseInt(match[2] || 0);
        let newTime = new Date(now.getTime());
        newTime.setHours(newTime.getHours() + hoursToAdd);
        newTime.setMinutes(newTime.getMinutes() + minutesToAdd);
        return newTime.getTime();
    }
    return null;
}

async function checkReminders(api) {
    const now = Date.now();
    let currentReminders = [];
    try { currentReminders = JSON.parse(fs.readFileSync(remindersFile, 'utf-8')); } catch (e) { return; }

    const stillPendingReminders = [];
    let updated = false;

    for (const reminder of currentReminders) {
        if (!reminder || typeof reminder.time !== 'number' || !reminder.threadID || !reminder.message) {
            console.warn("[REMINDER] Nh·∫Øc nh·ªü kh√¥ng h·ª£p l·ªá, b·ªè qua:", reminder);
            updated = true;
            continue;
        }
        if (reminder.time <= now) {
            try {
                let message = `üîî Ting ting! T∆∞·ªùng nh·∫Øc b·∫°n n√® ${reminder.userName ? `@${reminder.userName}` : '∆°i'}:\n\n"${reminder.message}"`;
                if (reminder.originalCommand) {
                    message += `\n\n(B·∫°n ƒë√£ d·∫∑n T∆∞·ªùng: "${reminder.originalCommand}")`;
                }
                if (api && typeof api.sendMessage === 'function') {
                    api.sendMessage(message, reminder.threadID, (err) => {
                        if (err) console.error("[REMINDER] L·ªói g·ª≠i tin nh·∫Øn nh·∫Øc nh·ªü:", err, "cho reminder ID:", reminder.id);
                    });
                    console.log(`[REMINDER] ƒê√£ g·ª≠i nh·∫Øc nh·ªü ID ${reminder.id.substring(0,6)} cho ${reminder.userName} ·ªü thread ${reminder.threadID}`);
                } else {
                    console.error("[REMINDER] API object kh√¥ng h·ª£p l·ªá ƒë·ªÉ g·ª≠i nh·∫Øc nh·ªü.");
                }
                updated = true;
            } catch (e) { console.error("[REMINDER] L·ªói nghi√™m tr·ªçng khi g·ª≠i nh·∫Øc nh·ªü:", e); }
        } else {
            stillPendingReminders.push(reminder);
        }
    }
    if (updated) {
        try {
            fs.writeFileSync(remindersFile, JSON.stringify(stillPendingReminders, null, 2));
        } catch (writeErr) {
            console.error("[REMINDER] L·ªói ghi l·∫°i file nh·∫Øc nh·ªü:", writeErr);
        }
    }
}

async function getWeatherData(city) {
    if (!OPENWEATHERMAP_API_KEY || OPENWEATHERMAP_API_KEY === "YOUR_OPENWEATHERMAP_API_KEY") {
        return "T√≠nh nƒÉng th·ªùi ti·∫øt ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t API Key. Admin ∆°i, gi√∫p T∆∞·ªùng v·ªõi!";
    }
    try {
        const response = await axios.get(`http://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${OPENWEATHERMAP_API_KEY}&units=metric&lang=vi`);
        const data = response.data;
        if (data.cod && data.cod.toString() !== "200") {
             return `T∆∞·ªùng kh√¥ng t√¨m th·∫•y th√¥ng tin th·ªùi ti·∫øt cho "${city}" (L·ªói: ${data.message || data.cod}). B·∫°n th·ª≠ l·∫°i t√™n kh√°c xem?`;
        }
        const weather = data.weather[0];
        return `‚òÄÔ∏è Th·ªùi ti·∫øt t·∫°i ${data.name}, ${data.sys.country} üå°Ô∏è\n` +
               `- Hi·ªán t·∫°i: ${Math.round(data.main.temp)}¬∞C, ${weather.description}\n` +
               `- C·∫£m gi√°c nh∆∞: ${Math.round(data.main.feels_like)}¬∞C\n` +
               `- ƒê·ªô ·∫©m: ${data.main.humidity}%\n` +
               `- Gi√≥: ${data.wind.speed} m/s (h∆∞·ªõng ${data.wind.deg}¬∞)\n` +
               `- M√¢y: ${data.clouds.all}%\n` +
               `- T·∫ßm nh√¨n: ${data.visibility ? data.visibility/1000 + ' km' : 'Kh√¥ng r√µ'}\n` +
               `- B√¨nh minh: ${new Date(data.sys.sunrise * 1000).toLocaleTimeString("vi-VN")}\n` +
               `- Ho√†ng h√¥n: ${new Date(data.sys.sunset * 1000).toLocaleTimeString("vi-VN")}`;
    } catch (error) {
        console.error("L·ªói l·∫•y th·ªùi ti·∫øt cho '"+city+"':", error.response?.data?.message || error.message);
        return `T∆∞·ªùng kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu th·ªùi ti·∫øt cho "${city}" r·ªìi. B·∫°n th·ª≠ l·∫°i t√™n th√†nh ph·ªë kh√°c xem sao. C√≥ th·ªÉ t√™n th√†nh ph·ªë kh√¥ng ƒë√∫ng ho·∫∑c API Key c√≥ v·∫•n ƒë·ªÅ.`;
    }
}

// --- MODULE EXPORTS ---
module.exports.config = {
  name: "tuong",
  version: "8.4.0", // On/Off logic refinement
  hasPermssion: 0,
  credits: "PCODER (Mega Update)",
  description: "T∆∞·ªùng AI v8.4 - Logic On/Off c·∫£i ti·∫øn, Nh·∫Øc nh·ªü, Th·ªùi ti·∫øt, Game, Help, Mood, QR, Media!",
  commandCategory: "ai",
  usages: [
    "tuong [n·ªôi dung] - Chat AI (khi AutoAI t·∫Øt ho·∫∑c mu·ªën ra l·ªánh tr·ª±c ti·∫øp)",
    "tuong on/off/b·∫≠t/t·∫Øt - B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr·∫£ l·ªùi trong nh√≥m.",
    "tuong status/tr·∫°ng th√°i - Ki·ªÉm tra tr·∫°ng th√°i AutoAI.",
    "g·ª≠i video/nh·∫°c/gif [t·ª´ kh√≥a] - T√¨m v√† ch·ªçn media.",
    "tuong ·∫£nh m√®o - T√¨m ·∫£nh m√®o ng·∫´u nhi√™n.",
    "tuong qr [link/vƒÉn b·∫£n] - T·∫°o QR cho vƒÉn b·∫£n/link.",
    "tuong qr wifi (t√™n [SSID] pass [M·∫≠t kh·∫©u] lo·∫°i [WPA/WEP]) - T·∫°o QR Wi-Fi.",
    "tuong qr li√™n h·ªá (t√™n [T√™n] sƒët [SƒêT] mail [Email]) - T·∫°o QR vCard.",
    "tuong qr v·ªã tr√≠ (lat [Vƒ© ƒë·ªô] lon [Kinh ƒë·ªô] nh√£n [T√™n]) - T·∫°o QR Geolocation.",
    "tuong nh·∫Øc [t√¥i/tui] [l·ªùi nh·∫Øn] [v√†o l√∫c/sau] [th·ªùi gian] - ƒê·∫∑t nh·∫Øc nh·ªü.",
    "tuong ds nh·∫Øc nh·ªü - Xem danh s√°ch nh·∫Øc nh·ªü c·ªßa b·∫°n.",
    "tuong x√≥a nh·∫Øc nh·ªü [ID] - X√≥a nh·∫Øc nh·ªü theo ID.",
    "tuong th·ªùi ti·∫øt [th√†nh ph·ªë] - Xem th·ªùi ti·∫øt.",
    "tuong ƒëo√°n s·ªë - Ch∆°i game ƒëo√°n s·ªë v·ªõi T∆∞·ªùng.",
    "tuong help ([t√™n l·ªánh]) - Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng c√°c l·ªánh c·ªßa T∆∞·ªùng.",
    "tuong set mood [h√†i h∆∞·ªõc/nghi√™m t√∫c/d·ªÖ th∆∞∆°ng/m·∫∑c ƒë·ªãnh] - ƒê·∫∑t t√≠nh c√°ch cho T∆∞·ªùng trong nh√≥m.",
    "tuong set gu nhac [edm], [nhac tre] - ƒê·∫∑t s·ªü th√≠ch nh·∫°c c·ªßa b·∫°n.",
    "(Reply v√†o ·∫£nh) [tuong ∆°i] [c√¢u h·ªèi v·ªÅ ·∫£nh] - H·ªèi T∆∞·ªùng v·ªÅ n·ªôi dung ·∫£nh ƒë∆∞·ª£c reply."
  ],
  cooldowns: 1,
  dependencies: { "uuid": "", "axios": "", "fs-extra": "", "@distube/ytdl-core": "", "fluent-ffmpeg": "", "qs": "" }
};

module.exports.onLoad = async function({ api }) { // api object ƒë∆∞·ª£c truy·ªÅn v√†o ƒë√¢y
  console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  console.log("‚ïë   T∆∞·ªùng AI v8.4.0 - S·∫µn s√†ng chi·∫øn ƒë·∫•u!  ‚ïë");
  console.log("‚ïë      Logic On/Off, Nh·∫Øc nh·ªü & More      ‚ïë");
  console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  fs.ensureDirSync(VISION_CACHE_DIR);
  fs.ensureDirSync(TMP_DIR);

  try {
    const currentUserID = api.getCurrentUserID(); 
    if (currentUserID) BOT_ID = currentUserID; // G√°n BOT_ID ·ªü ƒë√¢y n·∫øu getCurrentUserID l√† ƒë·ªìng b·ªô
    // N·∫øu getCurrentUserID l√† async, b·∫°n c·∫ßn: BOT_ID = await api.getCurrentUserID();
    console.log(`[INFO] BOT_ID ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o: ${BOT_ID}`);
  } catch (e) { 
    console.warn("[WARN] Kh√¥ng th·ªÉ l·∫•y BOT ID ngay khi onLoad (c√≥ th·ªÉ api.getCurrentUserID l√† async ho·∫∑c ch∆∞a s·∫µn s√†ng). S·∫Ω th·ª≠ l·∫°i trong handleEvent.");
  }

  setInterval(() => checkReminders(api), 60 * 1000);
};

module.exports.run = async function({ api, event, args }) {
  const commandBodyWhenRun = args.join(" ");
  // Khi l·ªánh ƒë∆∞·ª£c g·ªçi b·∫±ng run (v√≠ d·ª•: /tuong help), ta gi·∫£ l·∫≠p body nh∆∞ khi g·ªçi qua handleEvent
  const simulatedBody = `${this.config.name} ${commandBodyWhenRun}`.trim(); // this.config.name l√† "tuong"
  const newEvent = {...event, body: simulatedBody }; 
  return this.handleEvent({ api, event: newEvent });
};

module.exports.handleReply = async function ({ api, event, handleReply: hr }) { // ƒê·ªïi t√™n handleReply th√†nh hr ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n
  const { threadID, messageID, senderID, body } = event;
  const { type, author, choices, mediaType, quality, originalQuery, step, qrData = {}, gameData = {} } = hr;

  if (author !== senderID) return; 

  switch (type) {
    case "lyrics_youtube":
      if (body.toLowerCase() === "lyrics" && hr.songTitle) {
        api.unsendMessage(hr.messageID).catch(console.error);
        const lyric = await searchLyrics(hr.songTitle);
        return api.sendMessage(lyric, threadID, messageID);
      }
      break;
    case "yt_choice":
      api.unsendMessage(hr.messageID).catch(console.error);
      if (body.toLowerCase() === "kh√°c" || body.toLowerCase() === "k") {
        return api.sendMessage(`B·∫°n mu·ªën t√¨m l·∫°i ${mediaType === "mp3" ? "nh·∫°c": "video"} v·ªõi t·ª´ kh√≥a n√†o kh√°c h√¥ng? G√µ "g·ª≠i ${mediaType} [t·ª´ kh√≥a m·ªõi]" nha.`, threadID, messageID);
      }
      const choiceIndex = parseInt(body.trim()) - 1;
      if (choiceIndex >= 0 && choiceIndex < choices.length) {
        const chosenVideo = choices[choiceIndex];
        await downloadAndSendChosenMedia(api, threadID, messageID, senderID, chosenVideo, mediaType, quality);
      } else {
        api.sendMessage("L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá r·ªìi b·∫°n ∆°i. B·∫°n th·ª≠ l·∫°i s·ªë kh√°c nha!", threadID, messageID);
      }
      break;
    
    case "qr_interactive":
      const userAnswer = body.trim();
      if (userAnswer.toLowerCase() === "h·ªßy" || userAnswer.toLowerCase() === "cancel") {
        api.unsendMessage(hr.messageID).catch(console.error);
        return api.sendMessage("ƒê√£ h·ªßy t·∫°o QR nha b·∫°n.", threadID, messageID);
      }
      let nextStep = "";
      let promptMsg = "";
      let currentQrData = { ...qrData };

      switch (step) {
        case "wifi_ssid":
          currentQrData.ssid = userAnswer; nextStep = "wifi_pass";
          promptMsg = `OK, t√™n WiFi l√† "${userAnswer}". Gi·ªù cho T∆∞·ªùng xin m·∫≠t kh·∫©u (n·∫øu kh√¥ng c√≥ pass, g√µ "kh√¥ng" ho·∫∑c "nopass"):`;
          break;
        case "wifi_pass":
          currentQrData.pass = (userAnswer.toLowerCase() === "kh√¥ng" || userAnswer.toLowerCase() === "nopass") ? "" : userAnswer;
          nextStep = "wifi_type_finish";
          promptMsg = `ƒê√£ c√≥ m·∫≠t kh·∫©u. Lo·∫°i m√£ h√≥a l√† g√¨ b·∫°n ha? (WPA, WEP, ho·∫∑c g√µ "kh√¥ng" n·∫øu kh√¥ng r√µ/m·∫∑c ƒë·ªãnh WPA):`;
          break;
        case "wifi_type_finish":
          api.unsendMessage(hr.messageID).catch(console.error);
          currentQrData.wifiType = (userAnswer.toUpperCase() === "WEP" || userAnswer.toUpperCase() === "NOPASS") ? userAnswer.toUpperCase() : "WPA";
          if (userAnswer.toLowerCase() === "kh√¥ng") currentQrData.wifiType = "WPA";
          const wifiQrStr = `WIFI:T:${currentQrData.wifiType};S:${currentQrData.ssid};P:${currentQrData.pass};;`;
          return sendGeneratedQrCode(api, threadID, messageID, wifiQrStr, `üì± QR WiFi cho "${currentQrData.ssid}" ƒë√¢y b·∫°n ∆°i!`);

        case "vcard_name":
          currentQrData.name = userAnswer; nextStep = "vcard_phone";
          promptMsg = `T√™n: "${userAnswer}". S·ªë ƒëi·ªán tho·∫°i di ƒë·ªông l√† g√¨ b·∫°n nh·ªâ?`;
          break;
        case "vcard_phone":
          currentQrData.phone = userAnswer; nextStep = "vcard_email_finish";
          promptMsg = `SƒêT: "${userAnswer}". Email c·ªßa h·ªç l√† g√¨? (G√µ "kh√¥ng" n·∫øu kh√¥ng c√≥):`;
          break;
        case "vcard_email_finish":
          api.unsendMessage(hr.messageID).catch(console.error);
          if (userAnswer.toLowerCase() !== "kh√¥ng") currentQrData.email = userAnswer;
          let vCardStr = `BEGIN:VCARD\nVERSION:3.0\nFN:${currentQrData.name}\nTEL;TYPE=CELL:${currentQrData.phone}`;
          if (currentQrData.email) vCardStr += `\nEMAIL:${currentQrData.email}`; vCardStr += `\nEND:VCARD`;
          return sendGeneratedQrCode(api, threadID, messageID, vCardStr, `üë§ QR vCard cho "${currentQrData.name}" ƒë√¢y:`);

        case "geo_lat":
          currentQrData.lat = userAnswer; nextStep = "geo_lon";
          promptMsg = `Vƒ© ƒë·ªô: ${userAnswer}. Gi·ªù cho T∆∞·ªùng xin Kinh ƒë·ªô (Longitude):`;
          break;
        case "geo_lon":
          currentQrData.lon = userAnswer; nextStep = "geo_label_finish";
          promptMsg = `Kinh ƒë·ªô: ${userAnswer}. B·∫°n c√≥ mu·ªën th√™m nh√£n (t√™n ƒë·ªãa ƒëi·ªÉm) kh√¥ng? (G√µ "kh√¥ng" n·∫øu kh√¥ng mu·ªën):`;
          break;
        case "geo_label_finish":
          api.unsendMessage(hr.messageID).catch(console.error);
          if (userAnswer.toLowerCase() !== "kh√¥ng") currentQrData.label = userAnswer;
          let geoQrStr = `geo:${currentQrData.lat},${currentQrData.lon}`;
          if (currentQrData.label) geoQrStr += `?q=${encodeURIComponent(currentQrData.label)}`;
          return sendGeneratedQrCode(api, threadID, messageID, geoQrStr, `üìç QR v·ªã tr√≠ ${currentQrData.label ? `"${currentQrData.label}"` : `(${currentQrData.lat}, ${currentQrData.lon})`} ƒë√¢y:`);
        default:
            api.unsendMessage(hr.messageID).catch(console.error);
            return api.sendMessage("C√≥ l·ªói trong qu√° tr√¨nh t·∫°o QR t∆∞∆°ng t√°c. B·∫°n th·ª≠ l·∫°i t·ª´ ƒë·∫ßu nha.", threadID, messageID);
      }
      if (nextStep && promptMsg) {
        api.unsendMessage(hr.messageID).catch(console.error);
        api.sendMessage(promptMsg, threadID, (e, i) => {
            if (e) return console.error("L·ªói g·ª≠i c√¢u h·ªèi QR interactive:", e);
            if (global.client && global.client.handleReply && i) {
                global.client.handleReply.push({ name: module.exports.config.name, messageID: i.messageID, author: senderID, type: "qr_interactive", step: nextStep, qrData: currentQrData });
            }
        }, messageID);
      }
      break;
    
    case "game_guess_number":
      const guess = parseInt(body.trim());
      if (body.toLowerCase() === "b·ªè cu·ªôc") {
        api.unsendMessage(hr.messageID).catch(console.error);
        return api.sendMessage(`Ti·∫øc qu√°, b·∫°n ƒë√£ b·ªè cu·ªôc. S·ªë T∆∞·ªùng nghƒ© l√† ${gameData.target} ƒë√≥. L·∫ßn sau ch∆°i ti·∫øp nha!`, threadID, messageID);
      }
      if (isNaN(guess)) {
        return api.sendMessage("B·∫°n ƒëo√°n s·ªë m√†, nh·∫≠p s·ªë ƒëi ch·ª©! (Ho·∫∑c 'b·ªè cu·ªôc')", threadID, messageID);
      }
      gameData.attempts++;
      if (guess === gameData.target) {
        api.unsendMessage(hr.messageID).catch(console.error);
        api.sendMessage(`üéâ Bingo! S·ªë T∆∞·ªùng nghƒ© ch√≠nh l√† ${gameData.target}. B·∫°n ƒëo√°n tr√∫ng sau ${gameData.attempts} l·∫ßn. Si√™u qu√°!`, threadID, messageID);
      } else {
        const hint = guess < gameData.target ? "L·ªõn h∆°n m·ªôt ch√∫t n·ªØa!" : "Nh·ªè h∆°n x√≠u th√¥i!";
        api.unsendMessage(hr.messageID).catch(e => console.warn("L·ªói unsend game msg (c√≥ th·ªÉ do ƒë√£ b·ªã x√≥a):", e.message));
        api.sendMessage(`${hint} ƒêo√°n ti·∫øp nha. (L·∫ßn ƒëo√°n th·ª© ${gameData.attempts}, g√µ 'b·ªè cu·ªôc' ƒë·ªÉ d·ª´ng)`, threadID, (e, i) => {
          if (e) return console.error(e);
          if (global.client && global.client.handleReply && i) {
            global.client.handleReply.push({ ...hr, messageID: i.messageID, gameData }); // Push l·∫°i v·ªõi messageID m·ªõi
          }
        }, messageID);
      }
      break;
    default:
        // console.log(`[HandleReply] Kh√¥ng kh·ªõp type n√†o cho: ${type}`);
        break;
  }
};

// =======================================================================================
// ================================ HANDLE EVENT (TRUNG T√ÇM) ==============================
// =======================================================================================
module.exports.handleEvent = async function({ api, event }) {
  const { threadID, messageID, senderID, body = "", attachments = [], messageReply } = event;
  const userKey = `${threadID}_${senderID}`;

  if (!BOT_ID && api && typeof api.getCurrentUserID === 'function') {
      try {
          const currentID = api.getCurrentUserID();
          if (currentID) BOT_ID = currentID;
      } catch (e) { console.error("[ERROR] Kh√¥ng th·ªÉ l·∫•y BOT ID trong handleEvent:", e); }
  }

  if (!userData[userKey]) userData[userKey] = { music: [], video: [], gu: {}, xungho: "b·∫°n", nick: "", mood: "vui v·∫ª", memory: [] };
  if (!activeConversations[threadID]) activeConversations[threadID] = {};
  if (!groupData[threadID]) groupData[threadID] = { personality: "m·∫∑c ƒë·ªãnh" };

  const bodyLower = body.toLowerCase();
  const now = Date.now();
  const bodyParts = bodyLower.split(/\s+/);
  const commandPrefix = TUONGS.find(t => bodyParts[0] === t); // t ƒë√£ l√† lowercase

  // --- 1. X·ª¨ L√ù L·ªÜNH ON/OFF/STATUS (∆ØU TI√äN CAO NH·∫§T) ---
  if (commandPrefix && bodyParts.length > 1 && ["on", "off", "b·∫≠t", "t·∫Øt", "status", "tr·∫°ng th√°i"].includes(bodyParts[1].toLowerCase()) ) {
    const action = bodyParts[1].toLowerCase();
    const currentAutoAIState = autoAI[threadID] === true;

    if (action === "on" || action === "b·∫≠t") {
      if (currentAutoAIState) {
        return api.sendMessage("üü¢ T∆∞·ªùng ƒë√£ b·∫≠t r·ªìi m√† b·∫°n ∆°i! V·∫´n ƒëang h√≥ng chuy·ªán ƒë√¢y. üòâ", threadID, messageID);
      } else {
        autoAI[threadID] = true; saveData('autoAI');
        if (activeConversations[threadID]) activeConversations[threadID] = {};
        return api.sendMessage("üü¢ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr·∫£ l·ªùi cho nh√≥m n√†y! T∆∞·ªùng s·∫Ω l·∫Øng nghe t·∫•t c·∫£ nha. ü•≥", threadID, messageID);
      }
    } else if (action === "off" || action === "t·∫Øt") {
      if (!currentAutoAIState) {
        if(autoAI[threadID] === undefined) { autoAI[threadID] = false; saveData('autoAI'); }
        return api.sendMessage("üî¥ T∆∞·ªùng ƒëang ·ªü ch·∫ø ƒë·ªô kh√¥ng t·ª± ƒë·ªông tr·∫£ l·ªùi r·ªìi. C·∫ßn g√¨ c·ª© g·ªçi \"T∆∞·ªùng\" nh√©! üòä", threadID, messageID);
      } else {
        autoAI[threadID] = false; saveData('autoAI');
        if (activeConversations[threadID]) activeConversations[threadID] = {};
        return api.sendMessage("üî¥ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr·∫£ l·ªùi. G·ªçi \"T∆∞·ªùng ∆°i\" ho·∫∑c reply T∆∞·ªùng th√¨ T∆∞·ªùng m·ªõi tr·∫£ l·ªùi nha! üëã", threadID, messageID);
      }
    } else if (action === "status" || action === "tr·∫°ng th√°i") {
      if (currentAutoAIState) {
        return api.sendMessage(`üü¢ Ch·∫ø ƒë·ªô t·ª± ƒë·ªông c·ªßa T∆∞·ªùng ƒëang B·∫¨T trong nh√≥m n√†y.`, threadID, messageID);
      } else {
        return api.sendMessage(`üî¥ Ch·∫ø ƒë·ªô t·ª± ƒë·ªông c·ªßa T∆∞·ªùng ƒëang T·∫ÆT trong nh√≥m n√†y.`, threadID, messageID);
      }
    }
  }

  // --- 2. X√ÅC ƒê·ªäNH SHOULDRESPOND THEO LOGIC M·ªöI ---
  let shouldRespond = false;
  const isReplyToBotSpecific = messageReply && messageReply.senderID == BOT_ID;
  const isAutoAiOn = autoAI[threadID] === true;
  const isNameCalledGeneral = TUONGS.some(t => bodyLower.includes(t));

  if (isAutoAiOn) {
      shouldRespond = true;
      const isActiveConvWhenOn = activeConversations[threadID]?.[senderID] > now;
      if (BOT_ID && (isNameCalledGeneral || isActiveConvWhenOn || isReplyToBotSpecific)) {
          if (!activeConversations[threadID]) activeConversations[threadID] = {};
          activeConversations[threadID][senderID] = now + CONVERSATION_TIMEOUT_MS;
      }
  } else { // AutoAI is OFF
      if (isNameCalledGeneral) {
          shouldRespond = true;
          // KH√îNG qu·∫£n l√Ω activeConversations khi AutoAI OFF ƒë·ªÉ m·ªói l·∫ßn t∆∞∆°ng t√°c c·∫ßn g·ªçi t√™n l·∫°i.
      }
  }
  
  // --- 3. X·ª¨ L√ù ·∫¢NH ∆ØU TI√äN (N·∫æU SHOULDRESPOND L√Ä TRUE) ---
  if (shouldRespond) {
    if (messageReply && messageReply.attachments?.length > 0 && messageReply.attachments[0].type === "photo") {
      // Ph·∫£i c√≥ text trong reply HO·∫∂C g·ªçi t√™n T∆∞·ªùng ƒë·ªÉ h·ªèi v·ªÅ ·∫£nh (n·∫øu ch∆∞a c√≥ commandPrefix)
      // isNameCalledGeneral s·∫Ω bao g·ªìm c·∫£ tr∆∞·ªùng h·ª£p body c√≥ "tuong oi", commandPrefix l√† khi "tuong" ƒë·ª©ng ƒë·∫ßu.
      const triggerQuestion = body.trim() || (isNameCalledGeneral ? "Ph√¢n t√≠ch ·∫£nh n√†y gi√∫p T∆∞·ªùng v·ªõi." : "");
      if (triggerQuestion) { 
        const repliedPhotoUrl = messageReply.attachments[0].url;
        api.sendMessage("üñºÔ∏è B·∫°n h·ªèi v·ªÅ ·∫£nh ƒë∆∞·ª£c reply h·∫£? ƒê·ªÉ T∆∞·ªùng \"ng√¢m c·ª©u\" x√≠u...", threadID, messageID);
        try {
          const imgPath = path.join(VISION_CACHE_DIR, `${Date.now()}-${senderID}-replied.jpg`);
          const res = await axios.get(repliedPhotoUrl, { responseType: "arraybuffer" });
          fs.writeFileSync(imgPath, res.data);
          let visionPrompt = `B·∫°n l√† T∆∞·ªùng AI, tr·ª£ l√Ω ·∫£o th√¥ng minh v√† th√¢n thi·ªán. Ng∆∞·ªùi d√πng ƒë√£ TR·∫¢ L·ªúI m·ªôt h√¨nh ·∫£nh v√† h·ªèi: "${triggerQuestion}". H√£y ph√¢n t√≠ch k·ªπ h√¨nh ·∫£nh v√† tr·∫£ l·ªùi. QUAN TR·ªåNG: N·∫øu ·∫£nh l√† m√£ QR, h√£y gi·∫£i th√≠ch ng·∫Øn g·ªçn (2-3 c√¢u) m√£ ƒë√≥ ch·ª©a g√¨ (link, vƒÉn b·∫£n, v.v.) ho·∫∑c c√¥ng d·ª•ng, kh√¥ng m√¥ t·∫£ d√†i d√≤ng c√°c chi ti·∫øt kh√¥ng li√™n quan nh∆∞ n√∫t b·∫•m tr√™n m√†n h√¨nh. Gi·ªçng ƒëi·ªáu d·ªÖ th∆∞∆°ng nh√©!`;
          const geminiResponse = await geminiVisionRequest({ prompt: visionPrompt, imagePath: imgPath, threadID });
          api.sendMessage(`ü§ñ T∆∞·ªùng AI "soi" ƒë∆∞·ª£c t·ª´ ·∫£nh b·∫°n reply:\n\n${geminiResponse}`, threadID, () => { try {fs.unlinkSync(imgPath);} catch(e){console.warn("L·ªói x√≥a ·∫£nh t·∫°m (replied):", e.message);}}, messageID);
          return;
        } catch (e) { api.sendMessage(`·ªêi! T∆∞·ªùng kh√¥ng xem ƒë∆∞·ª£c ·∫£nh b·∫°n reply r·ªìi: ${e.message}`, threadID, messageID); return; }
      }
    }
    if (attachments?.length > 0 && attachments[0].type === "photo" && !messageReply) { // ·∫¢nh ƒë√≠nh k√®m m·ªõi, kh√¥ng ph·∫£i reply
      const imageUrl = attachments[0].url;
      const userMessage = body.trim();
      api.sendMessage("üñºÔ∏è Ooh T∆∞·ªùng th·∫•y c√≥ ·∫£nh m·ªõi n√®! ƒê·ªÉ T∆∞·ªùng ngh√≠a qua...", threadID, messageID);
      try {
        const imgPath = path.join(VISION_CACHE_DIR, `${Date.now()}-${senderID}-attached.jpg`);
        const res = await axios.get(imageUrl, { responseType: "arraybuffer" });
        fs.writeFileSync(imgPath, res.data);
        let visionPrompt = `B·∫°n l√† T∆∞·ªùng AI, tr·ª£ l√Ω ·∫£o th√¥ng minh, th√¢n thi·ªán.`;
        if (userMessage) visionPrompt += ` Ng∆∞·ªùi d√πng g·ª≠i ·∫£nh k√®m l·ªùi nh·∫Øn: "${userMessage}". H√£y ph√¢n t√≠ch ·∫£nh v√† ph·∫£n h·ªìi l·ªùi nh·∫Øn.`;
        else visionPrompt += ` Ng∆∞·ªùi d√πng g·ª≠i m·ªôt h√¨nh ·∫£nh. H√£y ph√¢n t√≠ch v√† m√¥ t·∫£ chi ti·∫øt.`;
        visionPrompt += ` QUAN TR·ªåNG: N·∫øu ·∫£nh l√† m√£ QR, h√£y gi·∫£i th√≠ch ng·∫Øn g·ªçn (2-3 c√¢u) m√£ ƒë√≥ ch·ª©a g√¨ (link, vƒÉn b·∫£n, v.v.) ho·∫∑c c√¥ng d·ª•ng, kh√¥ng m√¥ t·∫£ chi ti·∫øt kh√¥ng li√™n quan. Gi·ªçng ƒëi·ªáu d·ªÖ th∆∞∆°ng!`;
        const geminiResponse = await geminiVisionRequest({ prompt: visionPrompt, imagePath: imgPath, threadID });
        api.sendMessage(`ü§ñ Sau khi "qu√©t" ·∫£nh b·∫°n g·ª≠i, T∆∞·ªùng th·∫•y:\n\n${geminiResponse}`, threadID, () => { try {fs.unlinkSync(imgPath);} catch(e){console.warn("L·ªói x√≥a ·∫£nh t·∫°m (attached):", e.message);}}, messageID);
        return;
      } catch (e) { api.sendMessage(`·∫∂c! T∆∞·ªùng xem ·∫£nh b·∫°n g·ª≠i kh√¥ng ƒë∆∞·ª£c: ${e.message}`, threadID, messageID); return; }
    }
  }
  // --- K·∫æT TH√öC X·ª¨ L√ù ·∫¢NH ---

  // --- 4. GATE CH√çNH CHO C√ÅC L·ªÜNH C√íN L·∫†I ---
  if (!shouldRespond) return;

  // --- 5. KHAI B√ÅO actualCmdBody ---
  const actualCmdBody = commandPrefix ? body.substring(commandPrefix.length).trim().toLowerCase() : bodyLower;

  // --- 6. X·ª¨ L√ù C√ÅC L·ªÜNH C·ª§ TH·ªÇ KH√ÅC ---

  // L·ªÜNH HELP
  if ((commandPrefix && actualCmdBody.startsWith("help")) || (!commandPrefix && isAutoAiOn && bodyLower.startsWith("help"))) {
    const helpArg = (commandPrefix ? actualCmdBody.substring("help".length).trim() : bodyLower.substring("help".length).trim());
    let helpMsg = "‚ú® **T∆∞·ªùng AI Helper** ‚ú®\n\n";
    if (!helpArg) {
        helpMsg += "Ch√†o b·∫°n, T∆∞·ªùng c√≥ th·ªÉ gi√∫p g√¨ n√®? D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë l·ªánh T∆∞·ªùng bi·∫øt l√†m:\n";
        const categories = {};
        const sortedUsages = [...module.exports.config.usages].sort((a, b) => a.localeCompare(b));
        sortedUsages.forEach(usageFull => {
            const [usage, desc] = usageFull.split(" - ");
            let category = "Kh√°c";
            if (usage.includes("qr")) category = "T·∫°o QR Code";
            else if (usage.includes("nh·∫Øc")) category = "Nh·∫Øc Nh·ªü";
            else if (usage.includes("th·ªùi ti·∫øt")) category = "Th·ªùi Ti·∫øt";
            else if (usage.includes("game") || usage.includes("ƒëo√°n s·ªë")) category = "Gi·∫£i Tr√≠";
            else if (usage.includes("mood")) category = "C√†i ƒê·∫∑t T∆∞·ªùng";
            else if (usage.includes("video") || usage.includes("nh·∫°c") || usage.includes("gif") || usage.includes("·∫£nh")) category = "Media";
            else if (usage.includes("lyrics")) category = "L·ªùi B√†i H√°t";
            else if (usage.includes("gu nhac")) category = "C√° Nh√¢n H√≥a";
            else if (usage.includes("on/off") || usage.includes("status")) category = "ƒêi·ªÅu Khi·ªÉn Bot";
            if (!categories[category]) categories[category] = [];
            categories[category].push(`- \`${usage}\`${desc ? `: ${desc}` : ''}`);
        });
        const categoryOrder = ["ƒêi·ªÅu Khi·ªÉn Bot", "Media", "T·∫°o QR Code", "Nh·∫Øc Nh·ªü", "Th·ªùi Ti·∫øt", "Gi·∫£i Tr√≠", "C√° Nh√¢n H√≥a", "C√†i ƒê·∫∑t T∆∞·ªùng", "L·ªùi B√†i H√°t", "Kh√°c"];
        for (const category of categoryOrder) {
            if (categories[category]) {
                helpMsg += `\nüí† **${category.toUpperCase()}**:\n${categories[category].join("\n")}`;
            }
        }
        if (categories["Kh√°c"] && !categoryOrder.includes("Kh√°c")) {
             helpMsg += `\nüí† **KH√ÅC**:\n${categories["Kh√°c"].join("\n")}`;
        }
        helpMsg += "\n\nüí° G√µ `tuong help [t√™n l·ªánh]` ƒë·ªÉ xem chi ti·∫øt h∆°n (v√≠ d·ª•: `tuong help qr`).";
    } else {
        const foundUsages = module.exports.config.usages.filter(u => 
            u.toLowerCase().split(" - ")[0].includes(helpArg.toLowerCase()) || 
            u.toLowerCase().split(" - ")[1]?.toLowerCase().includes(helpArg.toLowerCase())
        );
        if (foundUsages.length > 0) {
            helpMsg += `üîç H∆∞·ªõng d·∫´n cho l·ªánh li√™n quan ƒë·∫øn "${helpArg}":\n`;
            foundUsages.forEach(u => helpMsg += `- ${u}\n`);
        } else {
             helpMsg += `T∆∞·ªùng kh√¥ng t√¨m th·∫•y l·ªánh n√†o kh·ªõp v·ªõi "${helpArg}" c·∫£. B·∫°n th·ª≠ l·∫°i v·ªõi t·ª´ kh√≥a kh√°c ho·∫∑c xem \`tuong help\` nha.`;
        }
    }
    return api.sendMessage(helpMsg, threadID, messageID);
  }
  
  // L·ªÜNH SET MOOD (C·∫ßn "tuong")
  if (commandPrefix && actualCmdBody.startsWith("set mood")) {
    const newMood = actualCmdBody.substring("set mood".length).trim().toLowerCase();
    const validMoods = ["m·∫∑c ƒë·ªãnh", "h√†i h∆∞·ªõc", "nghi√™m t√∫c", "d·ªÖ th∆∞∆°ng"];
    if (validMoods.includes(newMood)) {
        if (!groupData[threadID]) groupData[threadID] = {};
        groupData[threadID].personality = newMood;
        saveData('groupData');
        return api.sendMessage(`Okie! T·ª´ gi·ªù T∆∞·ªùng s·∫Ω chuy·ªÉn sang mood "${newMood}" trong nh√≥m n√†y nha. üòâ`, threadID, messageID);
    } else {
        return api.sendMessage(`T∆∞·ªùng ch∆∞a c√≥ mood "${newMood}" ƒë√¢u. B·∫°n th·ª≠ c√°c mood: ${validMoods.join(", ")}.`, threadID, messageID);
    }
  }

  // L·ªÜNH NH·∫ÆC NH·ªû (C·∫ßn "tuong")
  if (commandPrefix && actualCmdBody.startsWith("nh·∫Øc")) {
      const reminderTextRaw = body.substring(commandPrefix.length).trim();
      const reminderTextClean = reminderTextRaw.replace(/^nh·∫Øc\s+(t√¥i|tui)\s+/i, "").trim();
      const timeMatch = reminderTextClean.match(/(.+?)\s+(v√†o l√∫c|sau)\s+(.+)$/i);
      if (timeMatch) {
          const messageToRemind = timeMatch[1].trim();
          const timeInstruction = timeMatch[3].trim();
          const reminderTime = parseTime(timeInstruction);
          if (reminderTime && reminderTime > Date.now()) {
              const userInfo = await api.getUserInfo(senderID).catch(e => {console.warn("Kh√¥ng th·ªÉ l·∫•y userInfo cho nh·∫Øc nh·ªü:", e); return {[senderID]: {name: senderID.toString()}};});
              const userName = userInfo[senderID]?.name || senderID.toString();
              const newReminder = {
                  id: uuidv4(), userID: senderID, userName: userName, threadID: threadID,
                  time: reminderTime, message: messageToRemind, originalCommand: body, createdAt: Date.now()
              };
              let currentReminders = [];
              try { currentReminders = JSON.parse(fs.readFileSync(remindersFile, 'utf-8')); } catch (e) {}
              currentReminders.push(newReminder);
              fs.writeFileSync(remindersFile, JSON.stringify(currentReminders, null, 2));
              return api.sendMessage(`Okie ${userName}, T∆∞·ªùng s·∫Ω nh·∫Øc b·∫°n "${messageToRemind}" v√†o l√∫c ${new Date(reminderTime).toLocaleString("vi-VN")}.`, threadID, messageID);
          } else if (reminderTime && reminderTime <= Date.now()) { return api.sendMessage("Ui, th·ªùi gian b·∫°n ch·ªçn ƒë√£ qua m·∫•t r·ªìi. Ch·ªçn th·ªùi ƒëi·ªÉm trong t∆∞∆°ng lai nha!", threadID, messageID); } 
          else { return api.sendMessage("T∆∞·ªùng ch∆∞a hi·ªÉu th·ªùi gian b·∫°n mu·ªën nh·∫Øc. B·∫°n th·ª≠ l·∫°i v·ªõi ki·ªÉu nh∆∞ 'sau X ph√∫t/gi·ªù/ng√†y' ho·∫∑c 'HH:MM [DD/MM/YYYY]' xem sao.", threadID, messageID); }
      } else { return api.sendMessage("C√∫ ph√°p nh·∫Øc nh·ªü l√†: `tuong nh·∫Øc t√¥i [l·ªùi nh·∫Øn] v√†o l√∫c/sau [th·ªùi gian]` nha.", threadID, messageID); }
  }
  if ((commandPrefix && (actualCmdBody.startsWith("ds nh·∫Øc nh·ªü") || actualCmdBody.startsWith("xem nh·∫Øc nh·ªü"))) || 
      (!commandPrefix && isAutoAiOn && (bodyLower.startsWith("ds nh·∫Øc nh·ªü") || bodyLower.startsWith("xem nh·∫Øc nh·ªü")))) {
      let currentReminders = []; try { currentReminders = JSON.parse(fs.readFileSync(remindersFile, 'utf-8')); } catch (e) {}
      const userReminders = currentReminders.filter(r => r.userID === senderID && r.threadID === threadID);
      if (userReminders.length === 0) return api.sendMessage("B·∫°n ch∆∞a c√≥ nh·∫Øc nh·ªü n√†o v·ªõi T∆∞·ªùng trong nh√≥m n√†y h·∫øt.", threadID, messageID);
      let replyMsg = "üìù ƒê√¢y l√† danh s√°ch nh·∫Øc nh·ªü c·ªßa b·∫°n (s·∫Øp x·∫øp theo th·ªùi gian):\n";
      userReminders.sort((a,b) => a.time - b.time).forEach(r => { replyMsg += `\n- ID: \`${r.id.substring(0,6)}\`\n  N·ªôi dung: "${r.message}"\n  Th·ªùi gian: ${new Date(r.time).toLocaleString("vi-VN")}\n`; });
      replyMsg += "\nD√πng `tuong x√≥a nh·∫Øc nh·ªü [ID]` ƒë·ªÉ x√≥a nha.";
      return api.sendMessage(replyMsg, threadID, messageID);
  }
  if ((commandPrefix && actualCmdBody.startsWith("x√≥a nh·∫Øc nh·ªü")) || (!commandPrefix && isAutoAiOn && bodyLower.startsWith("x√≥a nh·∫Øc nh·ªü"))) {
      const idToDelete = (commandPrefix ? actualCmdBody.substring("x√≥a nh·∫Øc nh·ªü".length).trim() : bodyLower.substring("x√≥a nh·∫Øc nh·ªü".length).trim());
      if (!idToDelete) return api.sendMessage("B·∫°n mu·ªën x√≥a nh·∫Øc nh·ªü c√≥ ID n√†o? G√µ `tuong ds nh·∫Øc nh·ªü` ƒë·ªÉ xem ID nha.", threadID, messageID);
      let currentReminders = []; try { currentReminders = JSON.parse(fs.readFileSync(remindersFile, 'utf-8')); } catch (e) {}
      const initialLength = currentReminders.length;
      const filteredReminders = currentReminders.filter(r => !(r.id.startsWith(idToDelete) && r.userID === senderID && r.threadID === threadID));
      if (filteredReminders.length < initialLength) {
          fs.writeFileSync(remindersFile, JSON.stringify(filteredReminders, null, 2));
          return api.sendMessage(`ƒê√£ x√≥a nh·∫Øc nh·ªü c√≥ ID kh·ªõp v·ªõi "${idToDelete}" c·ªßa b·∫°n.`, threadID, messageID);
      } else { return api.sendMessage(`Kh√¥ng t√¨m th·∫•y nh·∫Øc nh·ªü n√†o c√≥ ID kh·ªõp "${idToDelete}" c·ªßa b·∫°n ƒë·ªÉ x√≥a.`, threadID, messageID); }
  }

  // L·ªÜNH TH·ªúI TI·∫æT
  if ((commandPrefix && actualCmdBody.startsWith("th·ªùi ti·∫øt")) || (!commandPrefix && isAutoAiOn && bodyLower.startsWith("th·ªùi ti·∫øt"))) {
      const city = (commandPrefix ? actualCmdBody.substring("th·ªùi ti·∫øt".length).trim() : bodyLower.substring("th·ªùi ti·∫øt".length).trim());
      if (!city) return api.sendMessage("B·∫°n mu·ªën xem th·ªùi ti·∫øt ·ªü th√†nh ph·ªë n√†o n√®?", threadID, messageID);
      const weatherInfo = await getWeatherData(city);
      return api.sendMessage(weatherInfo, threadID, messageID);
  }

  // L·ªÜNH GAME ƒêO√ÅN S·ªê
  if ((commandPrefix && actualCmdBody === "ƒëo√°n s·ªë") || (!commandPrefix && isAutoAiOn && bodyLower === "ƒëo√°n s·ªë")) {
      const targetNumber = Math.floor(Math.random() * 100) + 1;
      const gameData = { target: targetNumber, attempts: 0, threadID: threadID };
      api.sendMessage("Okie, ch∆°i ƒëo√°n s·ªë nha! T∆∞·ªùng ƒë√£ nghƒ© m·ªôt s·ªë t·ª´ 1 ƒë·∫øn 100 r·ªìi ƒë√≥. B·∫°n ƒëo√°n th·ª≠ xem? (G√µ 'b·ªè cu·ªôc' ƒë·ªÉ d·ª´ng)", threadID, (e, i) => {
          if (e) return console.error("L·ªói g·ª≠i game ƒëo√°n s·ªë:", e);
          if (global.client && global.client.handleReply && i) {
            global.client.handleReply.push({ name: module.exports.config.name, messageID: i.messageID, author: senderID, type: "game_guess_number", gameData });
          }
      }, messageID);
      return;
  }

  // X·ª¨ L√ù QR (Ch·ªâ ch·∫°y n·∫øu c√≥ "tuong" ho·∫∑c autoAI on)
  const qrTriggerWord = commandPrefix ? actualCmdBody : bodyLower; // Input ƒë·ªÉ check c√≥ "qr" kh√¥ng
  if (qrTriggerWord.startsWith("qr ") || qrTriggerWord.startsWith("qrcode ")) {
      const qrCmdPart = qrTriggerWord.startsWith("qr ") ? qrTriggerWord.substring("qr ".length).trim() : qrTriggerWord.substring("qrcode ".length).trim();
      if (qrCmdPart !== null) {
        let qrContentInput = qrCmdPart;
        // ... (To√†n b·ªô logic QR nh∆∞ phi√™n b·∫£n tr∆∞·ªõc, bao g·ªìm wifi, contact, geo, link, text, v√† interactive mode)
        // ƒê·∫£m b·∫£o c√°c nh√°nh ƒë·ªÅu c√≥ return. V√≠ d·ª•:
        if (!qrContentInput || qrContentInput === "help" || qrContentInput === "gi√∫p") { /* ... help QR ... */ return; }
        const wifiKeyword = "wifi"; const wifiFullPattern = /wifi\s+t√™n\s+([^;,\n]+)\s+pass\s+([^;,\n]+)(?:\s+lo·∫°i\s+(WPA|WEP|nopass))?/i; let match = qrContentInput.match(wifiFullPattern);
        if (match) { const [, ssid, pass, type = "WPA"] = match; const qrData = `WIFI:T:${type.toUpperCase()};S:${ssid.trim()};P:${pass.trim()};;`; return sendGeneratedQrCode(api, threadID, messageID, qrData, `üì± QR code ƒë·ªÉ k·∫øt n·ªëi WiFi "${ssid.trim()}" ƒë√¢y!`);} 
        else if (qrContentInput.toLowerCase().startsWith(wifiKeyword)) { return api.sendMessage("OK, t·∫°o QR WiFi nha. T√™n WiFi (SSID) l√† g√¨ b·∫°n ∆°i?", threadID, (e, i) => {if(i)global.client.handleReply.push({ name: module.exports.config.name, messageID: i.messageID, author: senderID, type: "qr_interactive", step: "wifi_ssid", qrData: {} });}, messageID);}
        // T∆∞∆°ng t·ª± cho contact, geo...
        const contactKeyword = "li√™n h·ªá"; const contactFullPattern = /li√™n h·ªá\s+t√™n\s+([^;,\n]+)\s+sƒët\s+([^;,\n]+)(?:\s+mail\s+([^;,\n]+))?/i; match = qrContentInput.match(contactFullPattern);
        if (match) {const [, name, phone, email] = match; let vCard = `BEGIN:VCARD\nVERSION:3.0\nFN:${name.trim()}\nTEL;TYPE=CELL:${phone.trim()}`; if (email) vCard += `\nEMAIL:${email.trim()}`; vCard += `\nEND:VCARD`; return sendGeneratedQrCode(api, threadID, messageID, vCard, `üë§ QR vCard cho "${name.trim()}" ƒë√¢y:`);}
        else if (qrContentInput.toLowerCase().startsWith(contactKeyword) || qrContentInput.toLowerCase().startsWith("danh b·∫°")) { return api.sendMessage("OK, t·∫°o QR danh b·∫° (vCard). Cho T∆∞·ªùng xin t√™n ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi ƒë√≥:", threadID, (e,i) => {if(i)global.client.handleReply.push({name:module.exports.config.name, messageID:i.messageID, author:senderID, type:"qr_interactive", step:"vcard_name",qrData:{}});}, messageID);}
        const locationKeyword = "v·ªã tr√≠"; const locationFullPattern = /v·ªã tr√≠\s+lat\s+([-\d.]+)\s+lon\s+([-\d.]+)(?:\s+nh√£n\s+(.+))?/i; match = qrContentInput.match(locationFullPattern);
        if (match) {const [, lat, lon, label] = match; let geoStr = `geo:${lat.trim()},${lon.trim()}`; if (label) geoStr += `?q=${encodeURIComponent(label.trim())}`; return sendGeneratedQrCode(api, threadID, messageID, geoStr, `üìç QR v·ªã tr√≠ ${label ? `"${label.trim()}"` : `(${lat.trim()}, ${lon.trim()})`} ƒë√¢y:`);}
        else if (qrContentInput.toLowerCase().startsWith(locationKeyword) || qrContentInput.toLowerCase().startsWith("map") || qrContentInput.toLowerCase().startsWith("b·∫£n ƒë·ªì")) { return api.sendMessage("OK, t·∫°o QR v·ªã tr√≠ (Geolocation). Vƒ© ƒë·ªô (Latitude) l√† bao nhi√™u b·∫°n nh·ªâ?", threadID, (e,i) => {if(i)global.client.handleReply.push({name:module.exports.config.name,messageID:i.messageID,author:senderID,type:"qr_interactive",step:"geo_lat",qrData:{}});}, messageID);}
        
        if (/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/i.test(qrContentInput)) {
          const url = qrContentInput.startsWith("http") ? qrContentInput : `http://${qrContentInput}`;
          return sendGeneratedQrCode(api, threadID, messageID, url, `üîó QR code cho link "${url.substring(0, 70)}${url.length > 70 ? '...' : ''}" n√®:`);
        } else if (qrContentInput) {
          return sendGeneratedQrCode(api, threadID, messageID, qrContentInput, `üìù QR code cho vƒÉn b·∫£n "${qrContentInput.substring(0, 70)}${qrContentInput.length > 70 ? '...' : ''}" ƒë√¢y:`);
        }
        return; // Return n·∫øu ƒë√£ v√†o logic QR v√† kh√¥ng match g√¨ th√™m
      }
  }

  // MEDIA, LYRICS, GU
  // parseMediaRequest c·∫ßn body g·ªëc ƒë·ªÉ ph√¢n t√≠ch ƒë√∫ng c√°c t·ª´ kh√≥a kh√¥ng c√≥ "tuong" ƒë·∫ßu
  const mediaRequestData = parseMediaRequest(body); 
  if (mediaRequestData) { // N·∫øu parseMediaRequest tr·∫£ v·ªÅ g√¨ ƒë√≥
      // Ch·ªâ x·ª≠ l√Ω media n·∫øu c√≥ g·ªçi t√™n T∆∞·ªùng ho·∫∑c AutoAI ƒëang b·∫≠t
      if (commandPrefix || isAutoAiOn) {
          // ƒê·∫∑c bi·ªát x·ª≠ l√Ω cho t√¨m ·∫£nh m√®o ƒë·ªÉ n√≥ ƒë∆∞·ª£c ∆∞u ti√™n h∆°n ·∫£nh chung (n·∫øu c√≥)
          if (mediaRequestData.type === "img" && /(m√®o|cat|meow)/i.test(mediaRequestData.query || "")) {
              const catImgUrl = await catImage();
              if (catImgUrl) return api.sendMessage({ body: " ·∫¢nh m√®o cute cho b·∫°n n√® üòª", attachment: await axios({ url: catImgUrl, responseType: "stream" }).then(r => r.data) }, threadID, messageID);
              else return api.sendMessage("Huhu, T∆∞·ªùng t√¨m ·∫£nh m√®o m√† kh√¥ng th·∫•y...", threadID, messageID);
          }
          // C√°c lo·∫°i media kh√°c ho·∫∑c ·∫£nh kh√¥ng ph·∫£i m√®o
          return sendMedia(api, event, mediaRequestData);
      }
  }
  
  if ((commandPrefix && actualCmdBody.startsWith("set gu nhac")) || (!commandPrefix && isAutoAiOn && bodyLower.startsWith("set gu nhac"))) { 
    return handleGu(api, event, body, userKey); // handleGu c·∫ßn body g·ªëc ƒë·ªÉ parse
  }
  
  const lyricTriggerWord = commandPrefix ? actualCmdBody : bodyLower;
  if (lyricTriggerWord.startsWith("lyrics ") || lyricTriggerWord.startsWith("l·ªùi b√†i h√°t ")) {
    const songTitle = lyricTriggerWord.replace(/^(lyrics|l·ªùi b√†i h√°t)\s+/i, "").trim();
    if (songTitle) {
        const lyric = await searchLyrics(songTitle);
        return api.sendMessage(lyric, threadID, messageID);
    } else {
        return api.sendMessage("B·∫°n mu·ªën t√¨m l·ªùi b√†i h√°t n√†o n√®? G√µ '[tuong] lyrics [t√™n b√†i h√°t]' nha.", threadID, messageID);
    }
  }
  
  // --- 7. AI TEXT M·∫∂C ƒê·ªäNH ---
  if (body.trim() !== "" && shouldRespond) { 
    if (commandPrefix && actualCmdBody === "") { // N·∫øu ch·ªâ g√µ "tuong"
        return api.sendMessage("T∆∞·ªùng nghe n√®! B·∫°n mu·ªën T∆∞·ªùng l√†m g√¨? G√µ `tuong help` ƒë·ªÉ xem c√°c l·ªánh nha.", threadID, messageID);
    }

    // Tr√°nh chat AI v·ªõi c√°c chu·ªói c√≥ v·∫ª l√† l·ªánh nh∆∞ng kh√¥ng kh·ªõp ho√†n to√†n
    const potentialCommandLookingStrings = ["help", "qr", "nh·∫Øc", "th·ªùi ti·∫øt", "ƒëo√°n s·ªë", "set mood", "set gu", "lyrics", "video", "nh·∫°c", "·∫£nh", "gif"];
    if (commandPrefix && potentialCommandLookingStrings.some(cmd => actualCmdBody.startsWith(cmd) && actualCmdBody !== cmd)) {
        // C√≥ th·ªÉ l√† g√µ sai l·ªánh, kh√¥ng n√™n ƒë∆∞a v√†o chat AI ngay
        // C√≥ th·ªÉ tr·∫£ v·ªÅ m·ªôt tin nh·∫Øn g·ª£i √Ω help ho·∫∑c im l·∫∑ng
        // console.log(`[DEBUG] C√≥ v·∫ª l√† l·ªánh g√µ sai: ${actualCmdBody}, kh√¥ng ƒë∆∞a v√†o chat AI.`);
    } else if (!commandPrefix && isAutoAiOn && potentialCommandLookingStrings.some(cmd => bodyLower.startsWith(cmd))) {
        // Khi autoAI on, n·∫øu user g√µ "video abc" m√† kh√¥ng kh·ªõp mediaReq, c≈©ng kh√¥ng n√™n t·ª± ƒë·ªông chat AI
        // console.log(`[DEBUG][AutoAI] C√≥ v·∫ª l√† l·ªánh kh√¥ng kh·ªõp: ${bodyLower}, kh√¥ng ƒë∆∞a v√†o chat AI.`);
    }
    else { // N·∫øu kh√¥ng ph·∫£i l√† c√°c tr∆∞·ªùng h·ª£p tr√™n, ti·∫øn h√†nh chat AI
        userData[userKey].memory.push({ time: Date.now(), text: body });
        if (userData[userKey].memory.length > 10) userData[userKey].memory.shift();
        
        const aiReplyText = await getAIResponse(body, userData[userKey], userData[userKey].memory, "", threadID);
        await api.sendMessage(aiReplyText, threadID, messageID);
        return; 
    }
  }
};